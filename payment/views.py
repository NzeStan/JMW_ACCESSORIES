from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, viewsets
from rest_framework.throttling import UserRateThrottle, AnonRateThrottle
from django.shortcuts import get_object_or_404
from django.conf import settings
from django.db import transaction
from django.utils import timezone
from .serializers import PaymentInitializeSerializer, PaymentVerifySerializer, PaymentTransactionSerializer
from .models import PaymentTransaction
from .utils import initialize_payment, verify_payment
from order.models import Order
from jmw.background_utils import send_payment_receipt_email_async, generate_payment_receipt_pdf_task
import logging

logger = logging.getLogger(__name__)


class PaymentInitializeRateThrottle(AnonRateThrottle):
    """Rate limit for payment initialization (10 requests per hour)"""
    rate = '10/hour'


class PaymentVerifyRateThrottle(UserRateThrottle):
    """Rate limit for payment verification (20 requests per hour)"""
    rate = '20/hour'


class InitializePaymentView(APIView):
    throttle_classes = [PaymentInitializeRateThrottle]

    @transaction.atomic
    def post(self, request):
        serializer = PaymentInitializeSerializer(data=request.data)
        if serializer.is_valid():
            order_id = serializer.validated_data['order_id']
            email = serializer.validated_data['email']

            order = get_object_or_404(Order, id=order_id)

            # Prevent duplicate payment initialization for already paid orders
            if order.paid:
                return Response(
                    {"error": "Order has already been paid"},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Check for existing pending transaction (idempotency)
            existing_transaction = PaymentTransaction.objects.filter(
                order=order,
                status='pending'
            ).first()

            if existing_transaction:
                logger.info(f"Reusing existing pending transaction: {existing_transaction.reference}")
                # Re-initialize with existing reference
                callback_url = settings.PAYMENT_CALLBACK_URL
                res = initialize_payment(
                    order.total_cost,
                    email,
                    existing_transaction.reference,
                    callback_url
                )

                if res and res.get('status'):
                    return Response(res['data'])

            # Create new transaction record (reference auto-generated by model)
            payment_transaction = PaymentTransaction.objects.create(
                order=order,
                amount=order.total_cost,
                email=email,
                status='pending'
            )

            # Add to legacy orders M2M for backwards compatibility
            payment_transaction.orders.add(order)

            # Initialize Paystack payment
            callback_url = settings.PAYMENT_CALLBACK_URL
            res = initialize_payment(
                order.total_cost,
                email,
                payment_transaction.reference,
                callback_url
            )

            if res and res.get('status'):
                logger.info(f"Payment initialized successfully: {payment_transaction.reference}")
                return Response(res['data'])

            # If initialization failed, mark transaction as failed
            payment_transaction.status = 'failed'
            payment_transaction.save()

            logger.error(f"Payment initialization failed for order: {order.reference}")
            return Response(
                {"error": "Payment initialization failed"},
                status=status.HTTP_400_BAD_REQUEST
            )

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class VerifyPaymentView(APIView):
    throttle_classes = [PaymentVerifyRateThrottle]

    @transaction.atomic
    def post(self, request):
        serializer = PaymentVerifySerializer(data=request.data)
        if serializer.is_valid():
            reference = serializer.validated_data['reference']

            # Idempotency check - if already verified, return success
            try:
                payment_transaction = PaymentTransaction.objects.select_for_update().get(reference=reference)

                if payment_transaction.status == 'success':
                    logger.info(f"Payment already verified: {reference}")
                    return Response({
                        "status": "success",
                        "message": "Payment already verified"
                    })

            except PaymentTransaction.DoesNotExist:
                logger.error(f"Transaction not found: {reference}")
                return Response(
                    {"error": "Transaction not found"},
                    status=status.HTTP_404_NOT_FOUND
                )

            # Verify with Paystack
            res = verify_payment(reference)

            if res and res.get('status') and res['data']['status'] == 'success':
                # Update payment transaction
                payment_transaction.status = 'success'
                payment_transaction.paystack_reference = res['data'].get('reference')
                payment_transaction.verified_at = timezone.now()
                payment_transaction.save()

                # Update associated order(s)
                if payment_transaction.order:
                    order = payment_transaction.order
                    order.paid = True
                    order.status = 'paid'
                    order.save()
                    logger.info(f"Order marked as paid: {order.reference}")

                # Update legacy orders M2M
                for order in payment_transaction.orders.all():
                    if not order.paid:
                        order.paid = True
                        order.status = 'paid'
                        order.save()

                # Send payment receipt email asynchronously
                try:
                    send_payment_receipt_email_async(str(payment_transaction.id))
                    logger.info(f"Payment receipt email queued for payment: {payment_transaction.reference}")
                except Exception as e:
                    logger.error(f"Failed to queue payment receipt email for {payment_transaction.reference}: {str(e)}")

                # Queue PDF receipt generation in background
                try:
                    generate_payment_receipt_pdf_task(str(payment_transaction.id))
                    logger.info(f"Payment receipt PDF task queued for payment: {payment_transaction.reference}")
                except Exception as e:
                    logger.error(f"Failed to queue payment receipt PDF for {payment_transaction.reference}: {str(e)}")

                return Response({
                    "status": "success",
                    "message": "Payment verified successfully"
                })

            # Payment verification failed
            payment_transaction.status = 'failed'
            payment_transaction.save()

            logger.warning(f"Payment verification failed: {reference}")
            return Response(
                {"error": "Payment verification failed"},
                status=status.HTTP_400_BAD_REQUEST
            )

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class PaymentTransactionViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = PaymentTransaction.objects.select_related('order').prefetch_related('orders')
    serializer_class = PaymentTransactionSerializer
    throttle_classes = [UserRateThrottle]

    def get_queryset(self):
        """Filter transactions by authenticated user's orders"""
        queryset = super().get_queryset()
        user = self.request.user

        if user.is_authenticated:
            if user.is_staff:
                return queryset
            # Filter to only show user's own payment transactions
            return queryset.filter(order__user=user)

        return queryset.none()
